--create normal tables
create table t1(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table r1(c1 int, c2 int) distributed randomly;
insert into t1 select i,i from generate_series(1,2)i;
insert into r1 select i,i from generate_series(1,2)i;
--check the plan
explain update t1 set c2 = t1.c2 + 1 from r1 where t1.c1 = r1.c1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Update on t1  (cost=2.04..4.15 rows=2 width=24)
   ->  Hash Join  (cost=2.04..4.15 rows=2 width=24)
         Hash Cond: (r1.c1 = t1.c1)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.06 rows=1 width=10)
               Hash Key: r1.c1
               ->  Seq Scan on r1  (cost=0.00..2.02 rows=1 width=10)
         ->  Hash  (cost=2.02..2.02 rows=1 width=18)
               ->  Seq Scan on t1  (cost=0.00..2.02 rows=1 width=18)
 Optimizer: legacy query optimizer
(9 rows)

update t1 set c2 = t1.c2 + 1 from r1 where t1.c1 = r1.c1;
select * from t1;
 c1 | c2 
----+----
  1 |  2
  2 |  3
(2 rows)

drop table t1;
drop table r1;
-- create inherits tables
create table t1(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t1h(c1 int, c2 int) inherits (t1);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
create table r1(c1 int, c2 int) distributed randomly;
insert into t1 select i,i from generate_series(1,2)i;
insert into t1h select i,i from generate_series(1,2)i;
insert into r1 select i,i from generate_series(1,2)i;
explain update t1 set c2 = t1.c2 + 1 from r1 where t1.c1 = r1.c1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Update on t1  (cost=2.04..8.31 rows=3 width=24)
   ->  Hash Join  (cost=2.04..4.15 rows=2 width=24)
         Hash Cond: (r1.c1 = t1.c1)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.06 rows=1 width=10)
               Hash Key: r1.c1
               ->  Seq Scan on r1  (cost=0.00..2.02 rows=1 width=10)
         ->  Hash  (cost=2.02..2.02 rows=1 width=18)
               ->  Seq Scan on t1  (cost=0.00..2.02 rows=1 width=18)
   ->  Hash Join  (cost=2.04..4.15 rows=2 width=24)
         Hash Cond: (r1.c1 = t1h.c1)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..2.06 rows=1 width=10)
               Hash Key: r1.c1
               ->  Seq Scan on r1  (cost=0.00..2.02 rows=1 width=10)
         ->  Hash  (cost=2.02..2.02 rows=1 width=18)
               ->  Seq Scan on t1h  (cost=0.00..2.02 rows=1 width=18)
 Optimizer: legacy query optimizer
(16 rows)

update t1 set c2 = t1.c2 + 1 from r1 where t1.c1 = r1.c1;
select * from t1;
 c1 | c2 
----+----
  1 |  2
  1 |  2
  2 |  3
  2 |  3
(4 rows)

drop table t1h;
drop table t1;
drop table r1;
-- create partition tables
create table part_t1(c1 int, c2 int, c3 int) partition by range(c3) 
	( START (1) END (2) EVERY (1),
    DEFAULT PARTITION other_c3);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "part_t1_1_prt_other_c3" for table "part_t1"
NOTICE:  CREATE TABLE will create partition "part_t1_1_prt_2" for table "part_t1"
create table r1(c1 int, c2 int) distributed randomly;
insert into r1 select i,i from generate_series(1,2)i;
insert into part_t1 select i,i,i from generate_series(1,2)i;
explain update part_t1 set c2 = part_t1.c2 + 1 from r1 where part_t1.c1 = r1.c1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Update on part_t1_1_prt_other_c3  (cost=1.08..2348.32 rows=104 width=28)
   ->  Hash Join  (cost=1.08..1174.16 rows=52 width=28)
         Hash Cond: (part_t1_1_prt_other_c3.c1 = r1.c1)
         ->  Seq Scan on part_t1_1_prt_other_c3  (cost=0.00..879.00 rows=25967 width=22)
         ->  Hash  (cost=1.06..1.06 rows=1 width=10)
               ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..1.06 rows=1 width=10)
                     Hash Key: r1.c1
                     ->  Seq Scan on r1  (cost=0.00..1.02 rows=1 width=10)
   ->  Hash Join  (cost=1.08..1174.16 rows=52 width=28)
         Hash Cond: (part_t1_1_prt_2.c1 = r1.c1)
         ->  Seq Scan on part_t1_1_prt_2  (cost=0.00..879.00 rows=25967 width=22)
         ->  Hash  (cost=1.06..1.06 rows=1 width=10)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..1.06 rows=1 width=10)
                     Hash Key: r1.c1
                     ->  Seq Scan on r1  (cost=0.00..1.02 rows=1 width=10)
 Optimizer: legacy query optimizer
(16 rows)

update part_t1 set c2 = part_t1.c2 + 1 from r1 where part_t1.c1 = r1.c1;
select * from part_t1;
 c1 | c2 | c3 
----+----+----
  2 |  3 |  2
  1 |  2 |  1
(2 rows)

drop table r1;
drop table part_t1;
